/*
* ============================================================================
*  Name     : CRollerCoasterContainer from RollerCoasterContainer.h
*  Part of  : RollerCoaster
*  Created  : 28.12.2004 by Plusplus
*  Implementation notes:
*     Initial content was generated by Series 60 Application Wizard.
*  Version  :
*  Copyright: 2004 Plusplus (plusplus AT free.fr)
* ============================================================================
*/

// INCLUDE FILES
#include "RollerCoasterContainer.h"

#include <eikenv.h>


// ================= MEMBER FUNCTIONS =======================

// ---------------------------------------------------------
// CRollerCoasterContainer::ConstructL(const TRect& aRect)
// EPOC two phased constructor
// ---------------------------------------------------------
//
void CRollerCoasterContainer::ConstructL(const TRect& /*aRect*/)
{
    iIsGenerating = ETrue;

    CreateWindowL();

    // Make the window fullscreen
    SetExtentToWholeScreen();
    ActivateL();

    EGLConfig Config;

    // Get the display for drawing graphics
    iEglDisplay = eglGetDisplay( EGL_DEFAULT_DISPLAY );
    if( iEglDisplay == NULL )
    {
        _LIT(KGetDisplayFailed, "eglGetDisplay failed");
        User::Panic( KGetDisplayFailed, 0 );
    }

    // Initialize display
    if( eglInitialize( iEglDisplay, NULL, NULL ) == EGL_FALSE )
    {
        _LIT(KInitializeFailed, "eglInitialize failed");
        User::Panic( KInitializeFailed, 0 );
    }

    EGLConfig *configList = NULL;
    EGLint numOfConfigs = 0;
    EGLint configSize = 0;

    // Get the number of possible EGLConfigs
    if( eglGetConfigs(iEglDisplay, configList, configSize, &numOfConfigs) == EGL_FALSE )
    {
        _LIT(KGetConfigsFailed, "eglGetConfigs failed");
        User::Panic( KGetConfigsFailed, 0 );
    }

    configSize = numOfConfigs;

    // Allocate memory for the configList
    configList = (EGLConfig*) User::Alloc( sizeof(EGLConfig)*configSize );
    if( configList == NULL )
    {
        _LIT(KConfigAllocFailed, "config alloc failed");
        User::Panic( KConfigAllocFailed, 0 );
    }

    /* Define properties for the wanted EGLSurface.
       To get the best possible performance, choose
       an EGLConfig with a buffersize matching
       the current window's display mode*/
    TDisplayMode DMode = Window().DisplayMode();
    TInt BufferSize = 0;

    switch( DMode )
    {
         case(EColor4K):
             BufferSize = 12;
             break;
         case(EColor64K):
             BufferSize = 16;
             break;
         case(EColor16M):
             BufferSize = 24;
             break;
         default:
             _LIT(KDModeError, "unsupported displaymode");
             User::Panic( KDModeError, 0 );
             break;
    }

    // Define properties for the wanted EGLSurface
    const EGLint attrib_list[] = {EGL_BUFFER_SIZE, BufferSize, EGL_DEPTH_SIZE, 16, EGL_NONE};

    // Choose an EGLConfig that best matches to the properties in attrib_list
    if( eglChooseConfig(iEglDisplay, attrib_list, configList, configSize, &numOfConfigs) == EGL_FALSE )
    {
        _LIT(KChooseConfigFailed, "eglChooseConfig failed");
        User::Panic( KChooseConfigFailed, 0 );
    }

    Config = configList[0];
    User::Free( configList );

    // Create a window where the graphics are blitted
    iEglSurface = eglCreateWindowSurface( iEglDisplay, Config, &Window(), NULL );
    if( iEglSurface == NULL )
    {
        _LIT(KCreateWindowSurfaceFailed, "eglCreateWindowSurface failed");
        User::Panic( KCreateWindowSurfaceFailed, 0 );
    }

    // Create a rendering context
    iEglContext = eglCreateContext( iEglDisplay, Config, NULL, NULL );
    if( iEglContext == NULL )
    {
        _LIT(KCreateContextFailed, "eglCreateContext failed");
        User::Panic( KCreateContextFailed, 0 );
    }

    // Make the context current. Binds context to the current rendering thread and surface.
    if( eglMakeCurrent(iEglDisplay, iEglSurface, iEglSurface, iEglContext) == EGL_FALSE )
    {
        _LIT(KMakeCurrentFailed, "eglMakeCurrent failed");
        User::Panic( KMakeCurrentFailed, 0 );
    }

    TSize size;
    size = this->Size();

    iRollerCoaster = CRollerCoaster::NewL( size.iWidth, size.iHeight );
    iRollerCoaster->AppInit();

    iIsGenerating = EFalse;

	// Create an active object for animating the scene
    iPeriodic = CPeriodic::NewL( CActive::EPriorityIdle );
    iPeriodic->Start( 100, 100, TCallBack(CRollerCoasterContainer::DrawCallBack, this) );
//for(int i = 0 ; i < 200000000 ; i++) i += CountComponentControls();
}

// Destructor
CRollerCoasterContainer::~CRollerCoasterContainer()
{
    delete iPeriodic;

    if( iRollerCoaster )
    {
        iRollerCoaster->AppExit();
        delete iRollerCoaster;
    }

    eglMakeCurrent(iEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
    eglDestroySurface(iEglDisplay, iEglSurface);
    eglDestroyContext(iEglDisplay, iEglContext);
    eglTerminate(iEglDisplay);
}

// ---------------------------------------------------------
// CRollerCoasterContainer::SizeChanged()
// Called by framework when the view size is changed
// ---------------------------------------------------------
//
void CRollerCoasterContainer::SizeChanged()
{
}

// ---------------------------------------------------------
// CRollerCoasterContainer::CountComponentControls() const
// ---------------------------------------------------------
//
TInt CRollerCoasterContainer::CountComponentControls() const
{
	// return nbr of controls inside this container
    return 0;
}

// ---------------------------------------------------------
// CRollerCoasterContainer::ComponentControl(TInt aIndex) const
// ---------------------------------------------------------
//
CCoeControl* CRollerCoasterContainer::ComponentControl(TInt /*aIndex*/) const
{
    return NULL;
}

// ---------------------------------------------------------
// CRollerCoasterContainer::Draw(const TRect& aRect) const
// ---------------------------------------------------------
//
void CRollerCoasterContainer::Draw(const TRect& aRect) const
{
    CWindowGc& gc = SystemGc();

    gc.Clear( aRect );

    if( iIsGenerating )
    {
        _LIT(KLoading, "Generating the track...");
        _LIT(KWait, "Please wait.");
        gc.SetPenColor(KRgbBlack);
        gc.UseFont(CEikonEnv::Static()->SymbolFont());
        gc.DrawText(KLoading, aRect, 50, (CGraphicsContext::TTextAlign)ECenter, 0);
        gc.DrawText(KWait, aRect, 70, (CGraphicsContext::TTextAlign)ECenter, 0);
    }
}

// ---------------------------------------------------------
// CRollerCoasterContainer::HandleControlEventL(
//     CCoeControl* aControl,TCoeEvent aEventType)
// ---------------------------------------------------------
//
void CRollerCoasterContainer::HandleControlEventL(CCoeControl* /*aControl*/,TCoeEvent /*aEventType*/)
{
}

// ---------------------------------------------------------
// CRollerCoasterContainer::Draw(const TRect& aRect) const
// ---------------------------------------------------------
//
int CRollerCoasterContainer::DrawCallBack(TAny* aInstance)
{
    CRollerCoasterContainer* instance = (CRollerCoasterContainer*)aInstance;
    instance->iRollerCoaster->AppCycle(0);
    eglSwapBuffers( instance->iEglDisplay, instance->iEglSurface );
    User::ResetInactivityTime();
    User::After(0);
    return 0;
}


// End of File
